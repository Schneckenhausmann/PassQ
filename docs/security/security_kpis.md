# PassQ Security Key Performance Indicators (KPIs) Dashboard

## Executive Summary

This document defines the key performance indicators (KPIs) and metrics used to measure the effectiveness of PassQ's security program. These metrics provide quantitative insights into security posture, incident response effectiveness, and compliance status.

## Security KPI Framework

### KPI Categories

1. **Preventive Security Metrics** - Measures to prevent security incidents
2. **Detective Security Metrics** - Measures to detect security threats
3. **Responsive Security Metrics** - Measures of incident response effectiveness
4. **Compliance Metrics** - Measures of regulatory and policy compliance
5. **Business Impact Metrics** - Measures of security's business value

## Core Security KPIs

### 1. Incident Response Metrics

#### Mean Time to Detection (MTTD)
**Definition**: Average time from when a security incident occurs to when it is detected.

**Target**: < 15 minutes for critical incidents, < 1 hour for high incidents

**Calculation**:
```sql
SELECT 
    AVG(TIMESTAMPDIFF(MINUTE, incident_occurred_at, detected_at)) as MTTD_minutes,
    severity,
    MONTH(detected_at) as month
FROM security_incidents 
WHERE detected_at >= CURDATE() - INTERVAL 12 MONTH
GROUP BY severity, MONTH(detected_at)
ORDER BY month;
```

**Dashboard Visualization**: Line chart showing MTTD trends by severity over time

#### Mean Time to Containment (MTTC)
**Definition**: Average time from detection to containment of security incidents.

**Target**: < 30 minutes for critical incidents, < 2 hours for high incidents

**Calculation**:
```sql
SELECT 
    AVG(TIMESTAMPDIFF(MINUTE, detected_at, contained_at)) as MTTC_minutes,
    severity,
    MONTH(detected_at) as month
FROM security_incidents 
WHERE contained_at IS NOT NULL
  AND detected_at >= CURDATE() - INTERVAL 12 MONTH
GROUP BY severity, MONTH(detected_at);
```

#### Mean Time to Recovery (MTTR)
**Definition**: Average time from incident detection to full system recovery.

**Target**: < 4 hours for critical incidents, < 24 hours for high incidents

**Calculation**:
```sql
SELECT 
    AVG(TIMESTAMPDIFF(HOUR, detected_at, resolved_at)) as MTTR_hours,
    severity,
    MONTH(detected_at) as month
FROM security_incidents 
WHERE resolved_at IS NOT NULL
  AND detected_at >= CURDATE() - INTERVAL 12 MONTH
GROUP BY severity, MONTH(detected_at);
```

### 2. Threat Detection Metrics

#### Security Alert Volume
**Definition**: Total number of security alerts generated by monitoring systems.

**Target**: Maintain manageable alert volume with < 10% false positive rate

**Calculation**:
```sql
SELECT 
    DATE(created_at) as date,
    COUNT(*) as total_alerts,
    COUNT(CASE WHEN false_positive = true THEN 1 END) as false_positives,
    ROUND(COUNT(CASE WHEN false_positive = true THEN 1 END) * 100.0 / COUNT(*), 2) as false_positive_rate
FROM security_alerts
WHERE created_at >= CURDATE() - INTERVAL 30 DAY
GROUP BY DATE(created_at)
ORDER BY date;
```

#### Threat Detection Accuracy
**Definition**: Percentage of legitimate threats correctly identified by security controls.

**Target**: > 95% detection accuracy for known threat patterns

**Calculation**:
```sql
SELECT 
    threat_type,
    COUNT(*) as total_threats,
    COUNT(CASE WHEN detected = true THEN 1 END) as detected_threats,
    ROUND(COUNT(CASE WHEN detected = true THEN 1 END) * 100.0 / COUNT(*), 2) as detection_rate
FROM threat_simulation_results
WHERE test_date >= CURDATE() - INTERVAL 90 DAY
GROUP BY threat_type;
```

#### Security Control Effectiveness
**Definition**: Percentage of attacks blocked by preventive security controls.

**Target**: > 98% block rate for automated attacks

**Calculation**:
```sql
SELECT 
    control_type,
    COUNT(*) as total_attempts,
    COUNT(CASE WHEN blocked = true THEN 1 END) as blocked_attempts,
    ROUND(COUNT(CASE WHEN blocked = true THEN 1 END) * 100.0 / COUNT(*), 2) as block_rate
FROM security_control_logs
WHERE timestamp >= CURDATE() - INTERVAL 30 DAY
GROUP BY control_type;
```

### 3. Authentication Security Metrics

#### Authentication Success Rate
**Definition**: Percentage of legitimate authentication attempts that succeed.

**Target**: > 99% success rate for legitimate users

**Calculation**:
```sql
SELECT 
    DATE(timestamp) as date,
    COUNT(*) as total_attempts,
    COUNT(CASE WHEN result = 'success' THEN 1 END) as successful_attempts,
    ROUND(COUNT(CASE WHEN result = 'success' THEN 1 END) * 100.0 / COUNT(*), 2) as success_rate
FROM authentication_logs
WHERE timestamp >= CURDATE() - INTERVAL 30 DAY
  AND user_type = 'legitimate'
GROUP BY DATE(timestamp);
```

#### Multi-Factor Authentication Adoption
**Definition**: Percentage of users with MFA enabled.

**Target**: > 95% MFA adoption rate

**Calculation**:
```sql
SELECT 
    COUNT(*) as total_users,
    COUNT(CASE WHEN mfa_enabled = true THEN 1 END) as mfa_users,
    ROUND(COUNT(CASE WHEN mfa_enabled = true THEN 1 END) * 100.0 / COUNT(*), 2) as mfa_adoption_rate
FROM users
WHERE account_status = 'active';
```

#### Account Compromise Rate
**Definition**: Number of confirmed account compromises per month.

**Target**: < 0.1% of total active accounts per month

**Calculation**:
```sql
SELECT 
    YEAR(incident_date) as year,
    MONTH(incident_date) as month,
    COUNT(*) as compromised_accounts,
    (SELECT COUNT(*) FROM users WHERE account_status = 'active') as total_accounts,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users WHERE account_status = 'active'), 4) as compromise_rate
FROM account_compromise_incidents
WHERE incident_date >= CURDATE() - INTERVAL 12 MONTH
GROUP BY YEAR(incident_date), MONTH(incident_date);
```

### 4. Vulnerability Management Metrics

#### Vulnerability Discovery Rate
**Definition**: Number of new vulnerabilities identified per month.

**Target**: Maintain consistent discovery rate with decreasing high/critical findings

**Calculation**:
```sql
SELECT 
    YEAR(discovered_date) as year,
    MONTH(discovered_date) as month,
    severity,
    COUNT(*) as vulnerability_count
FROM vulnerabilities
WHERE discovered_date >= CURDATE() - INTERVAL 12 MONTH
GROUP BY YEAR(discovered_date), MONTH(discovered_date), severity
ORDER BY year, month, severity;
```

#### Vulnerability Remediation Time
**Definition**: Average time to remediate vulnerabilities by severity.

**Target**: Critical < 24 hours, High < 7 days, Medium < 30 days

**Calculation**:
```sql
SELECT 
    severity,
    AVG(TIMESTAMPDIFF(HOUR, discovered_date, remediated_date)) as avg_remediation_hours,
    COUNT(*) as total_vulnerabilities,
    COUNT(CASE WHEN remediated_date IS NOT NULL THEN 1 END) as remediated_count
FROM vulnerabilities
WHERE discovered_date >= CURDATE() - INTERVAL 90 DAY
GROUP BY severity;
```

#### Patch Management Effectiveness
**Definition**: Percentage of systems with current security patches.

**Target**: > 95% of systems patched within SLA timeframes

**Calculation**:
```sql
SELECT 
    system_type,
    COUNT(*) as total_systems,
    COUNT(CASE WHEN patch_status = 'current' THEN 1 END) as patched_systems,
    ROUND(COUNT(CASE WHEN patch_status = 'current' THEN 1 END) * 100.0 / COUNT(*), 2) as patch_compliance_rate
FROM system_patch_status
GROUP BY system_type;
```

### 5. Compliance Metrics

#### Compliance Score
**Definition**: Overall compliance percentage across all applicable standards.

**Target**: > 95% compliance across all standards

**Calculation**:
```sql
SELECT 
    compliance_standard,
    COUNT(*) as total_controls,
    COUNT(CASE WHEN status = 'compliant' THEN 1 END) as compliant_controls,
    ROUND(COUNT(CASE WHEN status = 'compliant' THEN 1 END) * 100.0 / COUNT(*), 2) as compliance_score
FROM compliance_controls
WHERE assessment_date >= CURDATE() - INTERVAL 90 DAY
GROUP BY compliance_standard;
```

#### Audit Finding Resolution
**Definition**: Time to resolve audit findings by severity.

**Target**: Critical < 30 days, High < 60 days, Medium < 90 days

**Calculation**:
```sql
SELECT 
    finding_severity,
    AVG(TIMESTAMPDIFF(DAY, finding_date, resolution_date)) as avg_resolution_days,
    COUNT(*) as total_findings,
    COUNT(CASE WHEN resolution_date IS NOT NULL THEN 1 END) as resolved_findings
FROM audit_findings
WHERE finding_date >= CURDATE() - INTERVAL 12 MONTH
GROUP BY finding_severity;
```

### 6. Business Impact Metrics

#### Security-Related Downtime
**Definition**: Total system downtime caused by security incidents.

**Target**: < 0.1% annual downtime due to security incidents

**Calculation**:
```sql
SELECT 
    YEAR(incident_date) as year,
    MONTH(incident_date) as month,
    SUM(TIMESTAMPDIFF(MINUTE, incident_start, service_restored)) as total_downtime_minutes,
    COUNT(*) as incident_count
FROM security_incidents
WHERE service_restored IS NOT NULL
  AND incident_date >= CURDATE() - INTERVAL 12 MONTH
GROUP BY YEAR(incident_date), MONTH(incident_date);
```

#### Security Investment ROI
**Definition**: Return on investment for security spending.

**Target**: Positive ROI with quantifiable risk reduction

**Calculation**:
```sql
SELECT 
    investment_category,
    SUM(investment_amount) as total_investment,
    SUM(risk_reduction_value) as total_risk_reduction,
    ROUND((SUM(risk_reduction_value) - SUM(investment_amount)) * 100.0 / SUM(investment_amount), 2) as roi_percentage
FROM security_investments
WHERE investment_date >= CURDATE() - INTERVAL 12 MONTH
GROUP BY investment_category;
```

## KPI Dashboard Configuration

### Real-Time Security Dashboard

#### Dashboard Layout
```json
{
  "dashboard": {
    "title": "PassQ Security KPIs - Real-Time",
    "refresh_interval": "30s",
    "panels": [
      {
        "title": "Active Security Alerts",
        "type": "stat",
        "query": "SELECT COUNT(*) FROM security_alerts WHERE status = 'open'",
        "thresholds": [10, 50, 100]
      },
      {
        "title": "Mean Time to Detection",
        "type": "gauge",
        "query": "SELECT AVG(TIMESTAMPDIFF(MINUTE, occurred_at, detected_at)) FROM security_incidents WHERE detected_at >= NOW() - INTERVAL 24 HOUR",
        "target": 15,
        "unit": "minutes"
      },
      {
        "title": "Authentication Success Rate",
        "type": "gauge",
        "query": "SELECT ROUND(COUNT(CASE WHEN result = 'success' THEN 1 END) * 100.0 / COUNT(*), 2) FROM authentication_logs WHERE timestamp >= NOW() - INTERVAL 1 HOUR",
        "target": 99,
        "unit": "percent"
      },
      {
        "title": "Security Incidents Trend",
        "type": "timeseries",
        "query": "SELECT DATE(detected_at) as date, severity, COUNT(*) as count FROM security_incidents WHERE detected_at >= CURDATE() - INTERVAL 30 DAY GROUP BY DATE(detected_at), severity"
      }
    ]
  }
}
```

### Executive Security Dashboard

#### Monthly Executive Report
```json
{
  "executive_dashboard": {
    "title": "PassQ Security Executive Summary",
    "period": "monthly",
    "sections": [
      {
        "title": "Security Posture Overview",
        "metrics": [
          "overall_security_score",
          "compliance_percentage",
          "vulnerability_trend",
          "incident_count"
        ]
      },
      {
        "title": "Incident Response Performance",
        "metrics": [
          "mttd_trend",
          "mttc_trend",
          "mttr_trend",
          "resolution_rate"
        ]
      },
      {
        "title": "Business Impact",
        "metrics": [
          "security_downtime",
          "cost_avoidance",
          "roi_calculation",
          "user_impact"
        ]
      }
    ]
  }
}
```

## Automated KPI Reporting

### Daily KPI Collection

```python
#!/usr/bin/env python3
# Daily KPI collection script

import mysql.connector
import json
from datetime import datetime, timedelta

def collect_daily_kpis():
    """Collect and store daily security KPIs"""
    
    db = mysql.connector.connect(
        host='localhost',
        user='kpi_user',
        password='secure_password',
        database='passq_security'
    )
    
    cursor = db.cursor()
    
    # Collect authentication metrics
    auth_query = """
    SELECT 
        COUNT(*) as total_attempts,
        COUNT(CASE WHEN result = 'success' THEN 1 END) as successful_attempts,
        COUNT(CASE WHEN result = 'failure' THEN 1 END) as failed_attempts
    FROM authentication_logs 
    WHERE DATE(timestamp) = CURDATE()
    """
    
    cursor.execute(auth_query)
    auth_metrics = cursor.fetchone()
    
    # Collect incident metrics
    incident_query = """
    SELECT 
        COUNT(*) as total_incidents,
        AVG(TIMESTAMPDIFF(MINUTE, detected_at, contained_at)) as avg_containment_time,
        COUNT(CASE WHEN severity = 'critical' THEN 1 END) as critical_incidents
    FROM security_incidents 
    WHERE DATE(detected_at) = CURDATE()
    """
    
    cursor.execute(incident_query)
    incident_metrics = cursor.fetchone()
    
    # Store KPIs
    kpi_data = {
        'date': datetime.now().strftime('%Y-%m-%d'),
        'authentication': {
            'total_attempts': auth_metrics[0],
            'success_rate': (auth_metrics[1] / auth_metrics[0] * 100) if auth_metrics[0] > 0 else 0,
            'failed_attempts': auth_metrics[2]
        },
        'incidents': {
            'total_count': incident_metrics[0],
            'avg_containment_minutes': incident_metrics[1] or 0,
            'critical_count': incident_metrics[2]
        }
    }
    
    # Insert into KPI table
    insert_query = """
    INSERT INTO daily_kpis (date, kpi_data) 
    VALUES (%s, %s)
    ON DUPLICATE KEY UPDATE kpi_data = VALUES(kpi_data)
    """
    
    cursor.execute(insert_query, (kpi_data['date'], json.dumps(kpi_data)))
    db.commit()
    
    cursor.close()
    db.close()
    
    return kpi_data

if __name__ == "__main__":
    kpis = collect_daily_kpis()
    print(f"Daily KPIs collected: {json.dumps(kpis, indent=2)}")
```

### Weekly KPI Analysis

```python
#!/usr/bin/env python3
# Weekly KPI analysis and trending

import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

def generate_weekly_kpi_report():
    """Generate weekly KPI trend analysis"""
    
    # Load KPI data
    query = """
    SELECT date, kpi_data 
    FROM daily_kpis 
    WHERE date >= CURDATE() - INTERVAL 7 DAY
    ORDER BY date
    """
    
    df = pd.read_sql(query, connection)
    
    # Parse JSON data
    df['kpi_data'] = df['kpi_data'].apply(json.loads)
    
    # Extract metrics
    df['auth_success_rate'] = df['kpi_data'].apply(lambda x: x['authentication']['success_rate'])
    df['incident_count'] = df['kpi_data'].apply(lambda x: x['incidents']['total_count'])
    df['avg_containment'] = df['kpi_data'].apply(lambda x: x['incidents']['avg_containment_minutes'])
    
    # Generate trend charts
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    
    # Authentication success rate trend
    axes[0, 0].plot(df['date'], df['auth_success_rate'])
    axes[0, 0].set_title('Authentication Success Rate Trend')
    axes[0, 0].set_ylabel('Success Rate (%)')
    axes[0, 0].axhline(y=99, color='r', linestyle='--', label='Target')
    
    # Incident count trend
    axes[0, 1].bar(df['date'], df['incident_count'])
    axes[0, 1].set_title('Daily Incident Count')
    axes[0, 1].set_ylabel('Incident Count')
    
    # Containment time trend
    axes[1, 0].plot(df['date'], df['avg_containment'])
    axes[1, 0].set_title('Average Containment Time')
    axes[1, 0].set_ylabel('Minutes')
    axes[1, 0].axhline(y=30, color='r', linestyle='--', label='Target')
    
    plt.tight_layout()
    plt.savefig(f'/reports/weekly_kpi_report_{datetime.now().strftime("%Y%m%d")}.png')
    
    return df
```

## KPI Alerting and Thresholds

### Threshold Configuration

```yaml
# KPI alerting thresholds
kpi_thresholds:
  authentication_success_rate:
    warning: 95
    critical: 90
    
  mean_time_to_detection:
    warning: 30  # minutes
    critical: 60
    
  vulnerability_remediation_sla:
    critical_vulns: 24  # hours
    high_vulns: 168     # hours (7 days)
    
  compliance_score:
    warning: 90
    critical: 85
    
  false_positive_rate:
    warning: 15
    critical: 25
```

### Automated Alerting

```python
#!/usr/bin/env python3
# KPI threshold monitoring and alerting

def check_kpi_thresholds():
    """Monitor KPIs against defined thresholds"""
    
    # Load current KPI values
    current_kpis = get_current_kpis()
    
    # Load threshold configuration
    with open('/config/kpi_thresholds.yaml', 'r') as f:
        thresholds = yaml.safe_load(f)
    
    alerts = []
    
    # Check authentication success rate
    auth_rate = current_kpis['authentication_success_rate']
    if auth_rate < thresholds['authentication_success_rate']['critical']:
        alerts.append({
            'severity': 'critical',
            'metric': 'authentication_success_rate',
            'current_value': auth_rate,
            'threshold': thresholds['authentication_success_rate']['critical'],
            'message': f'Authentication success rate ({auth_rate}%) below critical threshold'
        })
    elif auth_rate < thresholds['authentication_success_rate']['warning']:
        alerts.append({
            'severity': 'warning',
            'metric': 'authentication_success_rate',
            'current_value': auth_rate,
            'threshold': thresholds['authentication_success_rate']['warning'],
            'message': f'Authentication success rate ({auth_rate}%) below warning threshold'
        })
    
    # Send alerts if any
    for alert in alerts:
        send_kpi_alert(alert)
    
    return alerts

def send_kpi_alert(alert):
    """Send KPI threshold alert"""
    
    # Email notification
    email_body = f"""
    KPI Alert: {alert['metric']}
    
    Severity: {alert['severity'].upper()}
    Current Value: {alert['current_value']}
    Threshold: {alert['threshold']}
    
    Message: {alert['message']}
    
    Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    """
    
    send_email(
        to=['security-team@passq.com'],
        subject=f"KPI Alert: {alert['metric']} - {alert['severity'].upper()}",
        body=email_body
    )
    
    # Slack notification for critical alerts
    if alert['severity'] == 'critical':
        send_slack_alert(
            channel='#security-alerts',
            message=f"🚨 Critical KPI Alert: {alert['message']}"
        )
```

## KPI Benchmarking

### Industry Benchmarks

| Metric | Industry Average | PassQ Target | Current Performance |
|--------|------------------|--------------|--------------------|
| MTTD | 197 days | 15 minutes | 12 minutes |
| MTTC | 69 days | 30 minutes | 25 minutes |
| MTTR | 287 days | 4 hours | 3.5 hours |
| False Positive Rate | 25% | < 10% | 8% |
| Patch Compliance | 60% | > 95% | 97% |
| MFA Adoption | 57% | > 95% | 98% |
| Vulnerability Remediation | 60 days | 7 days (high) | 5 days |

### Continuous Improvement

#### Monthly KPI Review Process
1. **Data Collection**: Gather all KPI data for the month
2. **Trend Analysis**: Identify patterns and anomalies
3. **Benchmark Comparison**: Compare against industry standards
4. **Root Cause Analysis**: Investigate underperforming metrics
5. **Action Planning**: Develop improvement initiatives
6. **Target Adjustment**: Update targets based on capability

#### Quarterly KPI Assessment
1. **Comprehensive Review**: Evaluate all KPIs and their relevance
2. **Stakeholder Feedback**: Gather input from security team and management
3. **Process Optimization**: Improve KPI collection and reporting
4. **Tool Enhancement**: Upgrade monitoring and reporting tools
5. **Training Needs**: Identify skill gaps and training requirements

---

**Document Control**
- **Version**: 1.0
- **Created**: 2025-01-27
- **Last Modified**: 2025-01-27
- **Next Review**: 2025-04-27
- **Classification**: Internal
- **Owner**: Security Team
- **Approved By**: CISO, Security Manager